"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const feature_hub_context_1 = require("./feature-hub-context");
const type_guards_1 = require("./internal/type-guards");
class InternalFeatureAppContainer extends React.PureComponent {
    constructor(props) {
        super(props);
        this.containerRef = React.createRef();
        const { baseUrl, beforeCreate, config, featureAppDefinition, featureAppId, featureAppManager } = props;
        try {
            this.featureAppScope = featureAppManager.createFeatureAppScope(featureAppId, featureAppDefinition, { baseUrl, config, beforeCreate });
            if (!type_guards_1.isFeatureApp(this.featureAppScope.featureApp)) {
                throw new Error('Invalid Feature App found. The Feature App must be an object with either 1) a `render` method that returns a React element, or 2) an `attachTo` method that accepts a container DOM element.');
            }
            this.state = { featureApp: this.featureAppScope.featureApp };
        }
        catch (error) {
            this.handleError(error);
            this.state = { featureAppError: error };
        }
    }
    componentDidCatch(error) {
        this.handleError(error);
        this.setState({ featureAppError: error });
    }
    componentDidMount() {
        const container = this.containerRef.current;
        if (container &&
            'featureApp' in this.state &&
            type_guards_1.isDomFeatureApp(this.state.featureApp)) {
            try {
                this.state.featureApp.attachTo(container);
            }
            catch (error) {
                this.componentDidCatch(error);
            }
        }
    }
    componentWillUnmount() {
        if (this.featureAppScope) {
            try {
                this.featureAppScope.release();
            }
            catch (error) {
                this.handleError(error);
            }
        }
    }
    render() {
        if ('featureAppError' in this.state) {
            return this.renderError(this.state.featureAppError);
        }
        if (type_guards_1.isReactFeatureApp(this.state.featureApp)) {
            try {
                return this.state.featureApp.render();
            }
            catch (error) {
                this.handleError(error);
                return this.renderError(error);
            }
        }
        return React.createElement("div", { ref: this.containerRef });
    }
    renderError(error) {
        return this.props.renderError ? this.props.renderError(error) : null;
    }
    handleError(error) {
        const { logger, onError } = this.props;
        if (onError) {
            onError(error);
        }
        else {
            logger.error(error);
        }
    }
}
/**
 * The `FeatureAppContainer` component allows the integrator to bundle Feature
 * Apps instead of loading them from a remote location. It can also be used by
 * a Feature App to render another Feature App as a child.
 *
 * When a Feature App throws an error while rendering or, in the case of a
 * [[ReactFeatureApp]], throws an error in a lifecycle method, the
 * `FeatureAppContainer` renders `null`. On the server, however, rendering
 * errors are not caught and must therefore be handled by the integrator.
 */
function FeatureAppContainer(props) {
    return (React.createElement(feature_hub_context_1.FeatureHubContextConsumer, null, ({ featureAppManager, logger }) => (React.createElement(InternalFeatureAppContainer, Object.assign({ featureAppManager: featureAppManager, logger: logger }, props)))));
}
exports.FeatureAppContainer = FeatureAppContainer;
//# sourceMappingURL=feature-app-container.js.map