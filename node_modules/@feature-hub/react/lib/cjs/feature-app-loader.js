"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const feature_app_container_1 = require("./feature-app-container");
const feature_hub_context_1 = require("./feature-hub-context");
const prepend_base_url_1 = require("./internal/prepend-base-url");
const inBrowser = typeof window === 'object' &&
    typeof document === 'object' &&
    document.nodeType === 9;
class InternalFeatureAppLoader extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {};
        this.errorHandled = false;
        this.mounted = false;
        const { baseUrl, featureAppManager, src: clientSrc, serverSrc, asyncSsrManager, addUrlForHydration, addStylesheetsForSsr } = props;
        const src = inBrowser ? clientSrc : serverSrc;
        if (!src) {
            if (inBrowser) {
                throw new Error('No src provided.');
            }
            return;
        }
        if (!inBrowser && addUrlForHydration) {
            addUrlForHydration(prepend_base_url_1.prependBaseUrl(baseUrl, clientSrc));
        }
        if (!inBrowser && addStylesheetsForSsr) {
            const css = this.prependCssHrefs();
            if (css) {
                addStylesheetsForSsr(css);
            }
        }
        const url = prepend_base_url_1.prependBaseUrl(baseUrl, src);
        const { error, promise: loadingPromise, value: featureAppDefinition } = featureAppManager.getAsyncFeatureAppDefinition(url);
        if (error) {
            this.handleError(error);
            this.state = { error };
        }
        else if (featureAppDefinition) {
            this.state = { featureAppDefinition };
        }
        else if (!inBrowser && asyncSsrManager) {
            asyncSsrManager.scheduleRerender(loadingPromise);
        }
    }
    async componentDidMount() {
        this.mounted = true;
        this.appendCss();
        if (this.state.featureAppDefinition) {
            return;
        }
        const { baseUrl, featureAppManager, src } = this.props;
        try {
            const featureAppDefinition = await featureAppManager.getAsyncFeatureAppDefinition(prepend_base_url_1.prependBaseUrl(baseUrl, src)).promise;
            if (this.mounted) {
                this.setState({ featureAppDefinition });
            }
        }
        catch (error) {
            this.handleAsyncError(error);
        }
    }
    componentWillUnmount() {
        this.mounted = false;
    }
    render() {
        const { baseUrl, beforeCreate, config, featureAppId, onError, renderError } = this.props;
        const { error, failedToHandleAsyncError, featureAppDefinition } = this.state;
        if (error) {
            if (failedToHandleAsyncError) {
                throw error;
            }
            return renderError ? renderError(error) : null;
        }
        if (!featureAppDefinition) {
            // A loading UI could be rendered here.
            return null;
        }
        return (React.createElement(feature_app_container_1.FeatureAppContainer, { baseUrl: baseUrl, beforeCreate: beforeCreate, config: config, featureAppId: featureAppId, featureAppDefinition: featureAppDefinition, onError: onError, renderError: renderError }));
    }
    appendCss() {
        const css = this.prependCssHrefs();
        if (!css) {
            return;
        }
        for (const { href, media = 'all' } of css) {
            if (!document.querySelector(`link[href="${href}"]`)) {
                document.head.appendChild(Object.assign(document.createElement('link'), {
                    rel: 'stylesheet',
                    href,
                    media
                }));
            }
        }
    }
    prependCssHrefs() {
        const { baseUrl, css } = this.props;
        if (!baseUrl || !css) {
            return css;
        }
        return css.map(({ href, media }) => ({
            href: prepend_base_url_1.prependBaseUrl(baseUrl, href),
            media
        }));
    }
    handleError(error) {
        if (this.errorHandled) {
            return;
        }
        this.errorHandled = true;
        if (this.props.onError) {
            this.props.onError(error);
        }
        else {
            this.logError(error);
        }
    }
    handleAsyncError(error) {
        try {
            this.handleError(error);
            if (this.mounted) {
                this.setState({ error });
            }
        }
        catch (handlerError) {
            if (this.mounted) {
                this.setState({ error: handlerError, failedToHandleAsyncError: true });
            }
        }
    }
    logError(error) {
        const { baseUrl, featureAppId, logger, src: clientSrc, serverSrc } = this.props;
        const src = inBrowser ? clientSrc : serverSrc;
        logger.error(`The Feature App for the src ${JSON.stringify(src && prepend_base_url_1.prependBaseUrl(baseUrl, src))} and the ID ${JSON.stringify(featureAppId)} could not be rendered.`, error);
    }
}
/**
 * The `FeatureAppLoader` component allows the integrator to load Feature Apps
 * from a remote location. It can also be used by a Feature App to render
 * another Feature App as a child.
 *
 * When a Feature App throws an error while rendering or, in the case of a
 * [[ReactFeatureApp]], throws an error in a lifecycle method, the
 * `FeatureAppLoader` renders `null`. On the server, however, rendering
 * errors are not caught and must therefore be handled by the integrator.
 */
function FeatureAppLoader(props) {
    return (React.createElement(feature_hub_context_1.FeatureHubContextConsumer, null, featureHubContextValue => (React.createElement(InternalFeatureAppLoader, Object.assign({}, featureHubContextValue, props)))));
}
exports.FeatureAppLoader = FeatureAppLoader;
//# sourceMappingURL=feature-app-loader.js.map