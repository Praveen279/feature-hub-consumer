{"version":3,"file":"async-ssr-manager.js","sourceRoot":"","sources":["../../../src/internal/async-ssr-manager.ts"],"names":[],"mappings":";;AAEA,2DAAoD;AAEpD,KAAK,UAAU,gBAAgB,CAAC,OAAe;IAC7C,MAAM,mCAAe,CAAC,OAAO,CAAC,CAAC;IAE/B,MAAM,KAAK,CAAC,+BAA+B,OAAO,MAAM,CAAC,CAAC;AAC5D,CAAC;AAED,MAAa,eAAe;IAG1B,YACmB,OAA+B,EAC/B,OAAgB;QADhB,YAAO,GAAP,OAAO,CAAwB;QAC/B,YAAO,GAAP,OAAO,CAAS;QAJlB,oBAAe,GAAG,IAAI,GAAG,EAAoB,CAAC;IAK5D,CAAC;IAEG,KAAK,CAAC,oBAAoB,CAAC,MAAoB;QACpD,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAEjD,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,QAAQ,EAAE;YACpC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CACtB,4JAA4J,CAC7J,CAAC;YAEF,OAAO,aAAa,CAAC;SACtB;QAED,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACvE,CAAC;IAEM,gBAAgB,CACrB,iBAAmC,OAAO,CAAC,OAAO,EAAE;QAEpD,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAC3C,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,MAAoB;QAC9C,IAAI,IAAI,GAAG,MAAM,EAAE,CAAC;QAEpB,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,GAAG,CAAC,EAAE;YACpC,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,GAAG,CAAC,EAAE;gBACpC,sEAAsE;gBACtE,sEAAsE;gBACtE,+CAA+C;gBAE/C,MAAM,uBAAuB,GAAG,KAAK,CAAC,IAAI,CACxC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAC9B,CAAC;gBAEF,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;gBAE7B,MAAM,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;aAC5C;YAED,IAAI,GAAG,MAAM,EAAE,CAAC;SACjB;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAnDD,0CAmDC","sourcesContent":["import {AsyncSsrManagerV1} from '..';\nimport {AsyncSsrManagerContext} from './async-ssr-manager-context';\nimport {setTimeoutAsync} from './set-timeout-async';\n\nasync function renderingTimeout(timeout: number): Promise<never> {\n  await setTimeoutAsync(timeout);\n\n  throw Error(`Got rendering timeout after ${timeout} ms.`);\n}\n\nexport class AsyncSsrManager implements AsyncSsrManagerV1 {\n  private readonly asyncOperations = new Set<Promise<unknown>>();\n\n  public constructor(\n    private readonly context: AsyncSsrManagerContext,\n    private readonly timeout?: number\n  ) {}\n\n  public async renderUntilCompleted(render: () => string): Promise<string> {\n    const renderPromise = this.renderingLoop(render);\n\n    if (typeof this.timeout !== 'number') {\n      this.context.logger.warn(\n        'No timeout is configured for the Async SSR Manager. This could lead to unexpectedly long render times or, in the worst case, never resolving render calls!'\n      );\n\n      return renderPromise;\n    }\n\n    return Promise.race([renderPromise, renderingTimeout(this.timeout)]);\n  }\n\n  public scheduleRerender(\n    asyncOperation: Promise<unknown> = Promise.resolve()\n  ): void {\n    this.asyncOperations.add(asyncOperation);\n  }\n\n  private async renderingLoop(render: () => string): Promise<string> {\n    let html = render();\n\n    while (this.asyncOperations.size > 0) {\n      while (this.asyncOperations.size > 0) {\n        // Storing a snapshot of the asynchronous operations and clearing them\n        // afterwards, allows that consecutive promises can be added while the\n        // current asynchronous operations are running.\n\n        const asyncOperationsSnapshot = Array.from(\n          this.asyncOperations.values()\n        );\n\n        this.asyncOperations.clear();\n\n        await Promise.all(asyncOperationsSnapshot);\n      }\n\n      html = render();\n    }\n\n    return html;\n  }\n}\n"]}