"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const set_timeout_async_1 = require("./set-timeout-async");
async function renderingTimeout(timeout) {
    await set_timeout_async_1.setTimeoutAsync(timeout);
    throw Error(`Got rendering timeout after ${timeout} ms.`);
}
class AsyncSsrManager {
    constructor(context, timeout) {
        this.context = context;
        this.timeout = timeout;
        this.asyncOperations = new Set();
    }
    async renderUntilCompleted(render) {
        const renderPromise = this.renderingLoop(render);
        if (typeof this.timeout !== 'number') {
            this.context.logger.warn('No timeout is configured for the Async SSR Manager. This could lead to unexpectedly long render times or, in the worst case, never resolving render calls!');
            return renderPromise;
        }
        return Promise.race([renderPromise, renderingTimeout(this.timeout)]);
    }
    scheduleRerender(asyncOperation = Promise.resolve()) {
        this.asyncOperations.add(asyncOperation);
    }
    async renderingLoop(render) {
        let html = render();
        while (this.asyncOperations.size > 0) {
            while (this.asyncOperations.size > 0) {
                // Storing a snapshot of the asynchronous operations and clearing them
                // afterwards, allows that consecutive promises can be added while the
                // current asynchronous operations are running.
                const asyncOperationsSnapshot = Array.from(this.asyncOperations.values());
                this.asyncOperations.clear();
                await Promise.all(asyncOperationsSnapshot);
            }
            html = render();
        }
        return html;
    }
}
exports.AsyncSsrManager = AsyncSsrManager;
//# sourceMappingURL=async-ssr-manager.js.map