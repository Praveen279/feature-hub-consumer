"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const async_value_1 = require("./async-value");
const is_feature_app_module_1 = require("./internal/is-feature-app-module");
/**
 * The `FeatureAppManager` manages the lifecycle of Feature Apps.
 */
class FeatureAppManager {
    constructor(featureServiceRegistry, options = {}) {
        this.featureServiceRegistry = featureServiceRegistry;
        this.options = options;
        this.asyncFeatureAppDefinitions = new Map();
        this.featureAppDefinitionsWithRegisteredOwnFeatureServices = new WeakSet();
        this.featureAppRetainers = new Map();
        this.logger = options.logger || console;
    }
    /**
     * Load a [[FeatureAppDefinition]] using the module loader the
     * [[FeatureAppManager]] was initilized with.
     *
     * @throws Throws an error if no module loader was provided on initilization.
     *
     * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a
     * module format compatible with the module loader.
     *
     * @returns An [[AsyncValue]] containing a promise that resolves with the
     * loaded [[FeatureAppDefinition]]. If called again with the same URL it
     * returns the same [[AsyncValue]]. The promise rejects when loading
     * fails, or when the loaded bundle doesn't export a [[FeatureAppDefinition]]
     * as default.
     */
    getAsyncFeatureAppDefinition(url) {
        let asyncFeatureAppDefinition = this.asyncFeatureAppDefinitions.get(url);
        if (!asyncFeatureAppDefinition) {
            asyncFeatureAppDefinition = this.createAsyncFeatureAppDefinition(url);
            this.asyncFeatureAppDefinitions.set(url, asyncFeatureAppDefinition);
        }
        return asyncFeatureAppDefinition;
    }
    /**
     * Create a [[FeatureAppScope]] which includes validating externals, binding
     * all available Feature Service dependencies, and calling the `create` method
     * of the [[FeatureAppDefinition]].
     *
     * @throws Throws an error if Feature Services that the
     * [[FeatureAppDefinition]] provides with its `ownFeatureServices` key fail to
     * be registered.
     * @throws Throws an error if the required externals can't be satisfied.
     * @throws Throws an error if the required Feature Services can't be
     * satisfied.
     * @throws Throws an error the [[FeatureAppDefinition]]'s `create` method
     * throws.
     *
     * @param featureAppID The ID of the Feature App to create a scope for.
     * @param featureAppDefinition The definition of the Feature App to create a
     * scope for.
     *
     * @returns A [[FeatureAppScope]] for the provided Feature App ID and
     * [[FeatureAppDefinition]]. A new scope is created for every call of
     * `createFeatureAppScope`, even with the same ID and definiton.
     */
    createFeatureAppScope(featureAppId, featureAppDefinition, options = {}) {
        const featureAppRetainer = this.getFeatureAppRetainer(featureAppId, featureAppDefinition, options);
        let released = false;
        return {
            featureApp: featureAppRetainer.featureApp,
            release: () => {
                if (released) {
                    this.logger.warn(`The Feature App with the ID ${JSON.stringify(featureAppId)} has already been released for this scope.`);
                }
                else {
                    released = true;
                    featureAppRetainer.release();
                }
            }
        };
    }
    /**
     * Preload a [[FeatureAppDefinition]] using the module loader the
     * [[FeatureAppManager]] was initilized with. Useful before hydration of a
     * server rendered page to avoid render result mismatch between client and
     * server due missing [[FeatureAppDefinition]]s.
     *
     * @throws Throws an error if no module loader was provided on initilization.
     *
     * @see [[getAsyncFeatureAppDefinition]] for further information.
     */
    async preloadFeatureApp(url) {
        await this.getAsyncFeatureAppDefinition(url).promise;
    }
    createAsyncFeatureAppDefinition(url) {
        const { moduleLoader: loadModule } = this.options;
        if (!loadModule) {
            throw new Error('No module loader provided.');
        }
        return new async_value_1.AsyncValue(loadModule(url).then(featureAppModule => {
            if (!is_feature_app_module_1.isFeatureAppModule(featureAppModule)) {
                throw new Error(`The Feature App module at the url ${JSON.stringify(url)} is invalid. A Feature App module must have a Feature App definition as default export. A Feature App definition is an object with at least a \`create\` method.`);
            }
            this.logger.info(`The Feature App module at the url ${JSON.stringify(url)} has been successfully loaded.`);
            return featureAppModule.default;
        }));
    }
    registerOwnFeatureServices(featureAppId, featureAppDefinition) {
        if (this.featureAppDefinitionsWithRegisteredOwnFeatureServices.has(featureAppDefinition)) {
            return;
        }
        if (featureAppDefinition.ownFeatureServiceDefinitions) {
            this.featureServiceRegistry.registerFeatureServices(featureAppDefinition.ownFeatureServiceDefinitions, featureAppId);
        }
        this.featureAppDefinitionsWithRegisteredOwnFeatureServices.add(featureAppDefinition);
    }
    getFeatureAppRetainer(featureAppId, featureAppDefinition, options) {
        let featureAppRetainer = this.featureAppRetainers.get(featureAppId);
        if (featureAppRetainer) {
            featureAppRetainer.retain();
        }
        else {
            this.registerOwnFeatureServices(featureAppId, featureAppDefinition);
            featureAppRetainer = this.createFeatureAppRetainer(featureAppDefinition, featureAppId, options);
        }
        return featureAppRetainer;
    }
    createFeatureAppRetainer(featureAppDefinition, featureAppId, options) {
        this.validateExternals(featureAppDefinition);
        const { baseUrl, beforeCreate, config } = options;
        const binding = this.featureServiceRegistry.bindFeatureServices(featureAppDefinition, featureAppId);
        const env = {
            baseUrl,
            config,
            featureAppId,
            featureServices: binding.featureServices
        };
        if (beforeCreate) {
            beforeCreate(env);
        }
        const featureApp = featureAppDefinition.create(env);
        this.logger.info(`The Feature App with the ID ${JSON.stringify(featureAppId)} has been successfully created.`);
        let retainCount = 1;
        const featureAppRetainer = {
            featureApp,
            retain: () => {
                retainCount += 1;
            },
            release: () => {
                retainCount -= 1;
                if (retainCount === 0) {
                    this.featureAppRetainers.delete(featureAppId);
                    binding.unbind();
                }
            }
        };
        this.featureAppRetainers.set(featureAppId, featureAppRetainer);
        return featureAppRetainer;
    }
    validateExternals(featureAppDefinition) {
        const { externalsValidator } = this.options;
        if (!externalsValidator) {
            return;
        }
        const { dependencies } = featureAppDefinition;
        if (dependencies && dependencies.externals) {
            externalsValidator.validate(dependencies.externals);
        }
    }
}
exports.FeatureAppManager = FeatureAppManager;
//# sourceMappingURL=feature-app-manager.js.map