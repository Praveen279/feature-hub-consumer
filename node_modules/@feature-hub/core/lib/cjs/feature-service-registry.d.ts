import { ExternalsValidator, RequiredExternals } from './externals-validator';
import { Logger } from './logger';
/**
 * A map of Feature Services with their ID as key and a semver-compatible
 * version string as value.
 */
export interface FeatureServiceConsumerDependencies {
    readonly [providerId: string]: string | undefined;
}
export interface FeatureServiceConsumerDefinition {
    readonly dependencies?: {
        /**
         * A map of required Feature Services with their ID as key and a
         * semver-compatible version string as value.
         */
        readonly featureServices?: FeatureServiceConsumerDependencies;
        readonly externals?: RequiredExternals;
    };
    readonly optionalDependencies?: {
        /**
         * A map of optional Feature Services with their ID as key and a
         * semver-compatible version string as value.
         */
        readonly featureServices?: FeatureServiceConsumerDependencies;
    };
}
export interface FeatureServices {
    [providerId: string]: unknown | undefined;
}
export interface FeatureServiceEnvironment<TFeatureServices extends FeatureServices> {
    /**
     * An object of required Feature Services that are semver-compatible with the
     * declared dependencies in the Feature App definition.
     */
    readonly featureServices: TFeatureServices;
}
export interface FeatureServiceProviderDefinition<TSharedFeatureService extends SharedFeatureService, TFeatureServices extends FeatureServices = FeatureServices> extends FeatureServiceConsumerDefinition {
    readonly id: string;
    create(env: FeatureServiceEnvironment<TFeatureServices>): TSharedFeatureService;
}
export interface FeatureServiceBinding<TFeatureService> {
    readonly featureService: TFeatureService;
    unbind?(): void;
}
export declare type FeatureServiceBinder<TFeatureService> = (consumerId: string) => FeatureServiceBinding<TFeatureService>;
export interface SharedFeatureService {
    readonly [version: string]: FeatureServiceBinder<unknown> | undefined;
}
export interface FeatureServicesBinding<TFeatureServices extends FeatureServices = FeatureServices> {
    readonly featureServices: TFeatureServices;
    unbind(): void;
}
export interface FeatureServiceRegistryOptions {
    /**
     * If the [[FeatureAppManager]] is configured with a
     * [[FeatureAppManagerOptions.moduleLoader]], to load Feature Apps from a
     * remote location that also provide their own Feature Services, i.e. the
     * Feature Services are included in a different bundle than the integrator
     * bundle, it might make sense to validate external dependencies that are
     * required by those Feature Services against the shared dependencies that are
     * provided by the integrator. This makes it possible that an error is already
     * thrown when registering a Feature Service with incompatible external
     * dependencies, and thus enables early feedback as to whether a Feature
     * Service is compatible with the integration environment.
     */
    readonly externalsValidator?: ExternalsValidator;
    /**
     * A custom logger that shall be used instead of `console`.
     */
    readonly logger?: Logger;
}
/**
 * The FeatureServiceRegistry provides Feature Services to dependent consumers.
 * The integrator should instantiate a singleton instance of the registry.
 */
export declare class FeatureServiceRegistry {
    private readonly options;
    private readonly sharedFeatureServices;
    private readonly consumerIds;
    private readonly logger;
    constructor(options?: FeatureServiceRegistryOptions);
    /**
     * Register a set of Feature Services to make them available for binding to
     * dependent consumers.
     *
     * @throws Throws an error if the dependencies of one of the provider
     * definitions can't be fulfilled.
     * @throws Throws an error if one of the registered Feature Services contains
     * an invalid version according to semver notation.
     *
     * @param providerDefinitions Feature Services that should be registered. A
     * Feature Service and its dependencies must either be registered together, or
     * the dependencies must have already been registered. It is not possible to
     * provide dependencies later. Sorting the provided definitions is not
     * necessary, since the registry takes care of registering the given
     * definitions in the correct order.
     * @param registrantId The ID of the entity that registers the provider
     * definitions.
     */
    registerFeatureServices(providerDefinitions: FeatureServiceProviderDefinition<SharedFeatureService>[], registrantId: string): void;
    /**
     * Bind all dependencies to a consumer.
     *
     * @throws Throws an error if non-optional dependencies can't be fulfilled.
     * @throws Throws an error if called with the same consumer ID more than once.
     *
     * @param consumerDefinition The definition of the consumer to which
     * dependencies should be bound.
     * @param consumerId The ID of the consumer to which dependencies should be
     * bound.
     */
    bindFeatureServices(consumerDefinition: FeatureServiceConsumerDefinition, consumerId: string): FeatureServicesBinding;
    private registerFeatureService;
    private bindFeatureService;
    private validateExternals;
    private validateFeatureServiceVersions;
}
