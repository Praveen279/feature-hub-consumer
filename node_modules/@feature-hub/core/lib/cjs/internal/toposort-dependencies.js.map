{"version":3,"file":"toposort-dependencies.js","sourceRoot":"","sources":["../../../src/internal/toposort-dependencies.ts"],"names":[],"mappings":";;;;;AAAA,wDAAgC;AAUhC,SAAS,WAAW,CAClB,KAAa;IAEb,OAAO,MAAM,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACnC,CAAC;AAED,SAAS,qBAAqB,CAC5B,aAAqB,EACrB,YAA0B;IAE1B,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC;AACnE,CAAC;AAED,SAAS,wBAAwB,CAC/B,eAAgC;IAEhC,OAAO,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAC9C,CAAC,kBAAkB,EAAE,cAAc,EAAE,EAAE;QACrC,MAAM,YAAY,GAAG,eAAe,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAEzD,0BAA0B;QAC1B,IAAI,CAAC,YAAY,EAAE;YACjB,OAAO,kBAAkB,CAAC;SAC3B;QAED,MAAM,eAAe,GAAG,qBAAqB,CAC3C,cAAc,EACd,YAAY,CACb,CAAC;QAEF,OAAO,CAAC,GAAG,kBAAkB,EAAE,GAAG,eAAe,CAAC,CAAC;IACrD,CAAC,EACD,EAAqB,CACtB,CAAC;AACJ,CAAC;AAED,SAAgB,oBAAoB,CAClC,eAAgC;IAEhC,MAAM,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3D,MAAM,eAAe,GAAG,wBAAwB,CAAC,eAAe,CAAC,CAAC;IAClE,MAAM,qBAAqB,GAAG,kBAAQ,CAAC,eAAe,CAAa,CAAC;IAEpE,sEAAsE;IACtE,oDAAoD;IACpD,qBAAqB,CAAC,IAAI,CACxB,GAAG,eAAe,CAAC,MAAM,CACvB,cAAc,CAAC,EAAE,CACf,eAAe,CAAC,GAAG,CAAC,cAAc,CAAC;QACnC,qBAAqB,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CACvD,CACF,CAAC;IAEF,0CAA0C;IAC1C,OAAO,qBAAqB,CAAC,OAAO,EAAE,CAAC;AACzC,CAAC;AAnBD,oDAmBC","sourcesContent":["import toposort from 'toposort';\n\nexport interface Dependencies {\n  readonly [dependencyName: string]: string | undefined;\n}\n\nexport type DependencyGraph = Map<string, Dependencies>;\n\ntype DependencyEdges = [string, string][];\n\nfunction createTuple<TFirst, TSecond>(\n  first: TFirst\n): (second: TSecond) => [TFirst, TSecond] {\n  return second => [first, second];\n}\n\nfunction createDependencyEdges(\n  dependentName: string,\n  dependencies: Dependencies\n): DependencyEdges {\n  return Object.keys(dependencies).map(createTuple(dependentName));\n}\n\nfunction createAllDependencyEdges(\n  dependencyGraph: DependencyGraph\n): DependencyEdges {\n  return Array.from(dependencyGraph.keys()).reduce(\n    (allDependencyEdges, dependencyName) => {\n      const dependencies = dependencyGraph.get(dependencyName);\n\n      /* istanbul ignore next */\n      if (!dependencies) {\n        return allDependencyEdges;\n      }\n\n      const dependencyEdges = createDependencyEdges(\n        dependencyName,\n        dependencies\n      );\n\n      return [...allDependencyEdges, ...dependencyEdges];\n    },\n    [] as DependencyEdges\n  );\n}\n\nexport function toposortDependencies(\n  dependencyGraph: DependencyGraph\n): string[] {\n  const dependencyNames = Array.from(dependencyGraph.keys());\n  const dependencyEdges = createAllDependencyEdges(dependencyGraph);\n  const sortedDependencyNames = toposort(dependencyEdges) as string[];\n\n  // Add modules that are not part of sortedDependencyNames because they\n  // don't have dependencies and are not a dependency.\n  sortedDependencyNames.push(\n    ...dependencyNames.filter(\n      dependencyName =>\n        dependencyGraph.has(dependencyName) &&\n        sortedDependencyNames.indexOf(dependencyName) === -1\n    )\n  );\n\n  // Reverse array to yield execution order.\n  return sortedDependencyNames.reverse();\n}\n"]}