"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const toposort_1 = __importDefault(require("toposort"));
function createTuple(first) {
    return second => [first, second];
}
function createDependencyEdges(dependentName, dependencies) {
    return Object.keys(dependencies).map(createTuple(dependentName));
}
function createAllDependencyEdges(dependencyGraph) {
    return Array.from(dependencyGraph.keys()).reduce((allDependencyEdges, dependencyName) => {
        const dependencies = dependencyGraph.get(dependencyName);
        /* istanbul ignore next */
        if (!dependencies) {
            return allDependencyEdges;
        }
        const dependencyEdges = createDependencyEdges(dependencyName, dependencies);
        return [...allDependencyEdges, ...dependencyEdges];
    }, []);
}
function toposortDependencies(dependencyGraph) {
    const dependencyNames = Array.from(dependencyGraph.keys());
    const dependencyEdges = createAllDependencyEdges(dependencyGraph);
    const sortedDependencyNames = toposort_1.default(dependencyEdges);
    // Add modules that are not part of sortedDependencyNames because they
    // don't have dependencies and are not a dependency.
    sortedDependencyNames.push(...dependencyNames.filter(dependencyName => dependencyGraph.has(dependencyName) &&
        sortedDependencyNames.indexOf(dependencyName) === -1));
    // Reverse array to yield execution order.
    return sortedDependencyNames.reverse();
}
exports.toposortDependencies = toposortDependencies;
//# sourceMappingURL=toposort-dependencies.js.map