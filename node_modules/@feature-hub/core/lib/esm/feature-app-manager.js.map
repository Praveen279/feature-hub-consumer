{"version":3,"file":"feature-app-manager.js","sourceRoot":"","sources":["../../src/feature-app-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {AsyncValue} from './async-value';\nimport {ExternalsValidator} from './externals-validator';\nimport {\n  FeatureServiceConsumerDefinition,\n  FeatureServiceProviderDefinition,\n  FeatureServiceRegistry,\n  FeatureServices,\n  SharedFeatureService\n} from './feature-service-registry';\nimport {isFeatureAppModule} from './internal/is-feature-app-module';\nimport {Logger} from './logger';\n\nexport interface FeatureAppEnvironment<\n  TFeatureServices extends FeatureServices,\n  TConfig\n> {\n  /**\n   * An object of required Feature Services that are semver-compatible with the\n   * declared dependencies in the Feature App definition.\n   */\n  readonly featureServices: TFeatureServices;\n\n  /**\n   * A config object that is provided by the integrator.\n   */\n  readonly config: TConfig | undefined;\n\n  /**\n   * The ID that the integrator has assigned to the Feature App instance.\n   */\n  readonly featureAppId: string;\n\n  /**\n   * The absolute or relative base URL of the Feature App's assets and/or BFF.\n   */\n  readonly baseUrl: string | undefined;\n}\n\nexport interface FeatureAppDefinition<\n  TFeatureApp,\n  TFeatureServices extends FeatureServices = FeatureServices,\n  TConfig = unknown\n> extends FeatureServiceConsumerDefinition {\n  readonly ownFeatureServiceDefinitions?: FeatureServiceProviderDefinition<\n    SharedFeatureService\n  >[];\n\n  create(env: FeatureAppEnvironment<TFeatureServices, TConfig>): TFeatureApp;\n}\n\nexport type ModuleLoader = (url: string) => Promise<unknown>;\n\nexport interface FeatureAppScope<TFeatureApp> {\n  readonly featureApp: TFeatureApp;\n\n  /**\n   * When the `FeatureAppScope` is not needed anymore, e.g. the Feature App is\n   * unmounted, `release` must be called. When all scopes for a Feature App ID\n   * have been released, the Feature App instance is destroyed.\n   */\n  release(): void;\n}\n\nexport interface FeatureAppScopeOptions<\n  TFeatureServices extends FeatureServices,\n  TConfig\n> {\n  /**\n   * The absolute or relative base URL of the Feature App's assets and/or BFF.\n   */\n  readonly baseUrl?: string;\n\n  /**\n   * A config object that is intended for a specific Feature App instance.\n   */\n  readonly config?: TConfig;\n\n  /**\n   * A callback that is called before the Feature App is created.\n   */\n  readonly beforeCreate?: (\n    env: FeatureAppEnvironment<TFeatureServices, TConfig>\n  ) => void;\n}\n\nexport interface FeatureAppManagerOptions {\n  /**\n   * For the `FeatureAppManager` to be able to load Feature Apps from a remote\n   * location, a module loader must be provided, (e.g. the\n   * `@feature-hub/module-loader-amd` package or the\n   * `@feature-hub/module-loader-commonjs` package).\n   */\n  readonly moduleLoader?: ModuleLoader;\n\n  /**\n   * When using a [[moduleLoader]], it might make sense to validate\n   * external dependencies that are required by Feature Apps against the\n   * shared dependencies that are provided by the integrator. This makes it\n   * possible that an error is already thrown when creating a Feature App with\n   * incompatible external dependencies, and thus enables early feedback as to\n   * whether a Feature App is compatible with the integration environment.\n   */\n  readonly externalsValidator?: ExternalsValidator;\n\n  /**\n   * A custom logger that shall be used instead of `console`.\n   */\n  readonly logger?: Logger;\n}\n\ntype FeatureAppModuleUrl = string;\ntype FeatureAppId = string;\n\ninterface FeatureAppRetainer<TFeatureApp> {\n  readonly featureApp: TFeatureApp;\n  retain(): void;\n  release(): void;\n}\n\n/**\n * The `FeatureAppManager` manages the lifecycle of Feature Apps.\n */\nexport class FeatureAppManager {\n  private readonly asyncFeatureAppDefinitions = new Map<\n    FeatureAppModuleUrl,\n    AsyncValue<FeatureAppDefinition<unknown>>\n  >();\n\n  private readonly featureAppDefinitionsWithRegisteredOwnFeatureServices = new WeakSet<\n    FeatureAppDefinition<unknown>\n  >();\n\n  private readonly featureAppRetainers = new Map<\n    FeatureAppId,\n    FeatureAppRetainer<unknown>\n  >();\n\n  private readonly logger: Logger;\n\n  public constructor(\n    private readonly featureServiceRegistry: FeatureServiceRegistry,\n    private readonly options: FeatureAppManagerOptions = {}\n  ) {\n    this.logger = options.logger || console;\n  }\n\n  /**\n   * Load a [[FeatureAppDefinition]] using the module loader the\n   * [[FeatureAppManager]] was initilized with.\n   *\n   * @throws Throws an error if no module loader was provided on initilization.\n   *\n   * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a\n   * module format compatible with the module loader.\n   *\n   * @returns An [[AsyncValue]] containing a promise that resolves with the\n   * loaded [[FeatureAppDefinition]]. If called again with the same URL it\n   * returns the same [[AsyncValue]]. The promise rejects when loading\n   * fails, or when the loaded bundle doesn't export a [[FeatureAppDefinition]]\n   * as default.\n   */\n  public getAsyncFeatureAppDefinition(\n    url: string\n  ): AsyncValue<FeatureAppDefinition<unknown>> {\n    let asyncFeatureAppDefinition = this.asyncFeatureAppDefinitions.get(url);\n\n    if (!asyncFeatureAppDefinition) {\n      asyncFeatureAppDefinition = this.createAsyncFeatureAppDefinition(url);\n\n      this.asyncFeatureAppDefinitions.set(url, asyncFeatureAppDefinition);\n    }\n\n    return asyncFeatureAppDefinition;\n  }\n\n  /**\n   * Create a [[FeatureAppScope]] which includes validating externals, binding\n   * all available Feature Service dependencies, and calling the `create` method\n   * of the [[FeatureAppDefinition]].\n   *\n   * @throws Throws an error if Feature Services that the\n   * [[FeatureAppDefinition]] provides with its `ownFeatureServices` key fail to\n   * be registered.\n   * @throws Throws an error if the required externals can't be satisfied.\n   * @throws Throws an error if the required Feature Services can't be\n   * satisfied.\n   * @throws Throws an error the [[FeatureAppDefinition]]'s `create` method\n   * throws.\n   *\n   * @param featureAppID The ID of the Feature App to create a scope for.\n   * @param featureAppDefinition The definition of the Feature App to create a\n   * scope for.\n   *\n   * @returns A [[FeatureAppScope]] for the provided Feature App ID and\n   * [[FeatureAppDefinition]]. A new scope is created for every call of\n   * `createFeatureAppScope`, even with the same ID and definiton.\n   */\n  public createFeatureAppScope<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices = FeatureServices,\n    TConfig = unknown\n  >(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig> = {}\n  ): FeatureAppScope<TFeatureApp> {\n    const featureAppRetainer = this.getFeatureAppRetainer<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >(featureAppId, featureAppDefinition, options);\n\n    let released = false;\n\n    return {\n      featureApp: featureAppRetainer.featureApp,\n\n      release: () => {\n        if (released) {\n          this.logger.warn(\n            `The Feature App with the ID ${JSON.stringify(\n              featureAppId\n            )} has already been released for this scope.`\n          );\n        } else {\n          released = true;\n          featureAppRetainer.release();\n        }\n      }\n    };\n  }\n\n  /**\n   * Preload a [[FeatureAppDefinition]] using the module loader the\n   * [[FeatureAppManager]] was initilized with. Useful before hydration of a\n   * server rendered page to avoid render result mismatch between client and\n   * server due missing [[FeatureAppDefinition]]s.\n   *\n   * @throws Throws an error if no module loader was provided on initilization.\n   *\n   * @see [[getAsyncFeatureAppDefinition]] for further information.\n   */\n  public async preloadFeatureApp(url: string): Promise<void> {\n    await this.getAsyncFeatureAppDefinition(url).promise;\n  }\n\n  private createAsyncFeatureAppDefinition(\n    url: string\n  ): AsyncValue<FeatureAppDefinition<unknown>> {\n    const {moduleLoader: loadModule} = this.options;\n\n    if (!loadModule) {\n      throw new Error('No module loader provided.');\n    }\n\n    return new AsyncValue(\n      loadModule(url).then(featureAppModule => {\n        if (!isFeatureAppModule(featureAppModule)) {\n          throw new Error(\n            `The Feature App module at the url ${JSON.stringify(\n              url\n            )} is invalid. A Feature App module must have a Feature App definition as default export. A Feature App definition is an object with at least a \\`create\\` method.`\n          );\n        }\n\n        this.logger.info(\n          `The Feature App module at the url ${JSON.stringify(\n            url\n          )} has been successfully loaded.`\n        );\n\n        return featureAppModule.default;\n      })\n    );\n  }\n\n  private registerOwnFeatureServices(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<unknown>\n  ): void {\n    if (\n      this.featureAppDefinitionsWithRegisteredOwnFeatureServices.has(\n        featureAppDefinition\n      )\n    ) {\n      return;\n    }\n\n    if (featureAppDefinition.ownFeatureServiceDefinitions) {\n      this.featureServiceRegistry.registerFeatureServices(\n        featureAppDefinition.ownFeatureServiceDefinitions,\n        featureAppId\n      );\n    }\n\n    this.featureAppDefinitionsWithRegisteredOwnFeatureServices.add(\n      featureAppDefinition\n    );\n  }\n\n  private getFeatureAppRetainer<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices = FeatureServices,\n    TConfig = unknown\n  >(\n    featureAppId: string,\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig>\n  ): FeatureAppRetainer<TFeatureApp> {\n    let featureAppRetainer = this.featureAppRetainers.get(featureAppId);\n\n    if (featureAppRetainer) {\n      featureAppRetainer.retain();\n    } else {\n      this.registerOwnFeatureServices(featureAppId, featureAppDefinition);\n\n      featureAppRetainer = this.createFeatureAppRetainer(\n        featureAppDefinition,\n        featureAppId,\n        options\n      );\n    }\n\n    return featureAppRetainer as FeatureAppRetainer<TFeatureApp>;\n  }\n\n  private createFeatureAppRetainer<\n    TFeatureApp,\n    TFeatureServices extends FeatureServices,\n    TConfig\n  >(\n    featureAppDefinition: FeatureAppDefinition<\n      TFeatureApp,\n      TFeatureServices,\n      TConfig\n    >,\n    featureAppId: string,\n    options: FeatureAppScopeOptions<TFeatureServices, TConfig>\n  ): FeatureAppRetainer<TFeatureApp> {\n    this.validateExternals(featureAppDefinition);\n\n    const {baseUrl, beforeCreate, config} = options;\n\n    const binding = this.featureServiceRegistry.bindFeatureServices(\n      featureAppDefinition,\n      featureAppId\n    );\n\n    const env: FeatureAppEnvironment<TFeatureServices, TConfig> = {\n      baseUrl,\n      config,\n      featureAppId,\n      featureServices: binding.featureServices as TFeatureServices\n    };\n\n    if (beforeCreate) {\n      beforeCreate(env);\n    }\n\n    const featureApp = featureAppDefinition.create(env);\n\n    this.logger.info(\n      `The Feature App with the ID ${JSON.stringify(\n        featureAppId\n      )} has been successfully created.`\n    );\n\n    let retainCount = 1;\n\n    const featureAppRetainer: FeatureAppRetainer<TFeatureApp> = {\n      featureApp,\n\n      retain: () => {\n        retainCount += 1;\n      },\n\n      release: () => {\n        retainCount -= 1;\n\n        if (retainCount === 0) {\n          this.featureAppRetainers.delete(featureAppId);\n          binding.unbind();\n        }\n      }\n    };\n\n    this.featureAppRetainers.set(featureAppId, featureAppRetainer);\n\n    return featureAppRetainer;\n  }\n\n  private validateExternals(\n    featureAppDefinition: FeatureServiceConsumerDefinition\n  ): void {\n    const {externalsValidator} = this.options;\n\n    if (!externalsValidator) {\n      return;\n    }\n\n    const {dependencies} = featureAppDefinition;\n\n    if (dependencies && dependencies.externals) {\n      externalsValidator.validate(dependencies.externals);\n    }\n  }\n}\n"]}