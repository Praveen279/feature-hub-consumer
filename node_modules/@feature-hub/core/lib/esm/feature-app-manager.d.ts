import { AsyncValue } from './async-value';
import { ExternalsValidator } from './externals-validator';
import { FeatureServiceConsumerDefinition, FeatureServiceProviderDefinition, FeatureServiceRegistry, FeatureServices, SharedFeatureService } from './feature-service-registry';
import { Logger } from './logger';
export interface FeatureAppEnvironment<TFeatureServices extends FeatureServices, TConfig> {
    /**
     * An object of required Feature Services that are semver-compatible with the
     * declared dependencies in the Feature App definition.
     */
    readonly featureServices: TFeatureServices;
    /**
     * A config object that is provided by the integrator.
     */
    readonly config: TConfig | undefined;
    /**
     * The ID that the integrator has assigned to the Feature App instance.
     */
    readonly featureAppId: string;
    /**
     * The absolute or relative base URL of the Feature App's assets and/or BFF.
     */
    readonly baseUrl: string | undefined;
}
export interface FeatureAppDefinition<TFeatureApp, TFeatureServices extends FeatureServices = FeatureServices, TConfig = unknown> extends FeatureServiceConsumerDefinition {
    readonly ownFeatureServiceDefinitions?: FeatureServiceProviderDefinition<SharedFeatureService>[];
    create(env: FeatureAppEnvironment<TFeatureServices, TConfig>): TFeatureApp;
}
export declare type ModuleLoader = (url: string) => Promise<unknown>;
export interface FeatureAppScope<TFeatureApp> {
    readonly featureApp: TFeatureApp;
    /**
     * When the `FeatureAppScope` is not needed anymore, e.g. the Feature App is
     * unmounted, `release` must be called. When all scopes for a Feature App ID
     * have been released, the Feature App instance is destroyed.
     */
    release(): void;
}
export interface FeatureAppScopeOptions<TFeatureServices extends FeatureServices, TConfig> {
    /**
     * The absolute or relative base URL of the Feature App's assets and/or BFF.
     */
    readonly baseUrl?: string;
    /**
     * A config object that is intended for a specific Feature App instance.
     */
    readonly config?: TConfig;
    /**
     * A callback that is called before the Feature App is created.
     */
    readonly beforeCreate?: (env: FeatureAppEnvironment<TFeatureServices, TConfig>) => void;
}
export interface FeatureAppManagerOptions {
    /**
     * For the `FeatureAppManager` to be able to load Feature Apps from a remote
     * location, a module loader must be provided, (e.g. the
     * `@feature-hub/module-loader-amd` package or the
     * `@feature-hub/module-loader-commonjs` package).
     */
    readonly moduleLoader?: ModuleLoader;
    /**
     * When using a [[moduleLoader]], it might make sense to validate
     * external dependencies that are required by Feature Apps against the
     * shared dependencies that are provided by the integrator. This makes it
     * possible that an error is already thrown when creating a Feature App with
     * incompatible external dependencies, and thus enables early feedback as to
     * whether a Feature App is compatible with the integration environment.
     */
    readonly externalsValidator?: ExternalsValidator;
    /**
     * A custom logger that shall be used instead of `console`.
     */
    readonly logger?: Logger;
}
/**
 * The `FeatureAppManager` manages the lifecycle of Feature Apps.
 */
export declare class FeatureAppManager {
    private readonly featureServiceRegistry;
    private readonly options;
    private readonly asyncFeatureAppDefinitions;
    private readonly featureAppDefinitionsWithRegisteredOwnFeatureServices;
    private readonly featureAppRetainers;
    private readonly logger;
    constructor(featureServiceRegistry: FeatureServiceRegistry, options?: FeatureAppManagerOptions);
    /**
     * Load a [[FeatureAppDefinition]] using the module loader the
     * [[FeatureAppManager]] was initilized with.
     *
     * @throws Throws an error if no module loader was provided on initilization.
     *
     * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a
     * module format compatible with the module loader.
     *
     * @returns An [[AsyncValue]] containing a promise that resolves with the
     * loaded [[FeatureAppDefinition]]. If called again with the same URL it
     * returns the same [[AsyncValue]]. The promise rejects when loading
     * fails, or when the loaded bundle doesn't export a [[FeatureAppDefinition]]
     * as default.
     */
    getAsyncFeatureAppDefinition(url: string): AsyncValue<FeatureAppDefinition<unknown>>;
    /**
     * Create a [[FeatureAppScope]] which includes validating externals, binding
     * all available Feature Service dependencies, and calling the `create` method
     * of the [[FeatureAppDefinition]].
     *
     * @throws Throws an error if Feature Services that the
     * [[FeatureAppDefinition]] provides with its `ownFeatureServices` key fail to
     * be registered.
     * @throws Throws an error if the required externals can't be satisfied.
     * @throws Throws an error if the required Feature Services can't be
     * satisfied.
     * @throws Throws an error the [[FeatureAppDefinition]]'s `create` method
     * throws.
     *
     * @param featureAppID The ID of the Feature App to create a scope for.
     * @param featureAppDefinition The definition of the Feature App to create a
     * scope for.
     *
     * @returns A [[FeatureAppScope]] for the provided Feature App ID and
     * [[FeatureAppDefinition]]. A new scope is created for every call of
     * `createFeatureAppScope`, even with the same ID and definiton.
     */
    createFeatureAppScope<TFeatureApp, TFeatureServices extends FeatureServices = FeatureServices, TConfig = unknown>(featureAppId: string, featureAppDefinition: FeatureAppDefinition<TFeatureApp, TFeatureServices, TConfig>, options?: FeatureAppScopeOptions<TFeatureServices, TConfig>): FeatureAppScope<TFeatureApp>;
    /**
     * Preload a [[FeatureAppDefinition]] using the module loader the
     * [[FeatureAppManager]] was initilized with. Useful before hydration of a
     * server rendered page to avoid render result mismatch between client and
     * server due missing [[FeatureAppDefinition]]s.
     *
     * @throws Throws an error if no module loader was provided on initilization.
     *
     * @see [[getAsyncFeatureAppDefinition]] for further information.
     */
    preloadFeatureApp(url: string): Promise<void>;
    private createAsyncFeatureAppDefinition;
    private registerOwnFeatureServices;
    private getFeatureAppRetainer;
    private createFeatureAppRetainer;
    private validateExternals;
}
